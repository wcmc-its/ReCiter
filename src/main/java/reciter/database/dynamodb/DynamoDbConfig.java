package reciter.database.dynamodb;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.BeanCreationException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.type.filter.AnnotationTypeFilter;

import lombok.extern.slf4j.Slf4j;
import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
import software.amazon.awssdk.auth.credentials.DefaultCredentialsProvider;
import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedUuidExtension;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbAttribute;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbPartitionKey;
import software.amazon.awssdk.http.apache.ApacheHttpClient;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.dynamodb.DynamoDbClient;
import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;
import software.amazon.awssdk.services.dynamodb.model.BillingMode;
import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;
import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;
import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;
import software.amazon.awssdk.services.dynamodb.model.DynamoDbException;
import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;
import software.amazon.awssdk.services.dynamodb.model.KeyType;
import software.amazon.awssdk.services.dynamodb.model.ListTablesRequest;
import software.amazon.awssdk.services.dynamodb.model.ListTablesResponse;
import software.amazon.awssdk.services.dynamodb.model.ProvisionedThroughput;
import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;
import software.amazon.awssdk.services.dynamodb.model.TableStatus;


@Slf4j
@Configuration
public class DynamoDbConfig {

	private String amazonDynamoDBEndpoint = System.getenv("AMAZON_DYNAMODB_ENDPOINT");

	private String amazonAWSAccessKey = System.getenv("AMAZON_AWS_ACCESS_KEY");

	private String amazonAWSSecretKey = System.getenv("AMAZON_AWS_SECRET_KEY");

	private String basePackage = "reciter.database.dynamodb.model";

	@Value("${aws.dynamoDb.local.port}")
	private String dynamoDbLocalPort;

	@Value("${aws.dynamoDb.local.region}")
	private String dynamodbLocalRegion;

	@Value("${aws.dynamoDb.local.accesskey}")
	private String dynamodbLocalAccessKey;

	@Value("${aws.dynamoDb.local.secretkey}")
	private String dynamodbLocalSecretKey;

	@Value("${aws.dynamoDb.local.dbpath}")
	private String dynamoDbPath;

	@Value("${aws.dynamoDb.local}")
	private boolean isDynamoDbLocal;

	@Value("${aws.dynamodb.settings.region}")
	private String dyanmodbRegion;

	@Value("${aws.dynamodb.settings.table.readcapacityunits}")
	private Long READ_CAPACITY_UNITS;

	@Value("${aws.dynamodb.settings.table.writecapacityunits}")
	private Long WRITE_CAPACITY_UNITS;

	@Value("${aws.dynamodb.settings.table.create}")
	private boolean createDynamoDbTable;

	@Value("${aws.dynamodb.settings.table.billingmode}")
	private BillingMode billingMode;
	
	@Value("${aws.dynamoDb.analysisOutput.table.name}")
	private String analysisOutputTableName;
	
	@Value("${aws.dynamoDb.analysisOutput.model.name}")
	private String analysisOutputModelName;
	
	
	@Bean
	public DynamoDbEnhancedClient dynamoDbEnhancedClient(DynamoDbClient dynamoDbClient) {
		return DynamoDbEnhancedClient.builder().dynamoDbClient(dynamoDbClient)
				 .extensions(AutoGeneratedTimestampRecordExtension.create(), AutoGeneratedUuidExtension.create())
				.build();
	}
	
	@Bean
	public DynamoDbClient dynamoDbClient() {
		DynamoDbClient dynamoDbClient = null;

		if (isDynamoDbLocal) {
			try {

				dynamoDbClient = DynamoDbClient.builder().httpClient(ApacheHttpClient.create())
						.endpointOverride(URI.create("http://localhost:" + dynamoDbLocalPort))
						//.endpointOverride(URI.create("http://dynamodb:" + dynamoDbLocalPort))
						//.endpointOverride(URI.create("http://host.docker.internal:" + dynamoDbLocalPort))
						
						.region(Region.of(dynamodbLocalRegion)) 
						.credentialsProvider(StaticCredentialsProvider.create(
								AwsBasicCredentials.create(dynamodbLocalAccessKey, dynamodbLocalSecretKey)))
						.build();

			} catch (Exception e) {
				log.error(e.getLocalizedMessage());
			}

		} else {
			if (StringUtils.isEmpty(dyanmodbRegion)) {
				throw new BeanCreationException(
						"The aws.dynamodb.settings.region is not set in application.propeties file. Please provide a valid  AWS region such as us-east-1 or eu-central-1. For list of valid regions see - https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html#Concepts.RegionsAndAvailabilityZones.Availability");
			}

			dynamoDbClient = DynamoDbClient.builder().region(Region.of(dyanmodbRegion))
					.credentialsProvider(DefaultCredentialsProvider.create()).build();

		}
		if (dynamoDbClient != null) {
			if (createDynamoDbTable) {
				log.info("Creating all required dynamodb tables for ReCiter");
				createTables(dynamoDbClient);
			} else {
				log.info("Skipping table creation for dynamoDB.");
				log.warn(
						"This might cause issues with your application if tables are not created. Please set the aws.dynamodb.settings.table.create in application.properties as true if not already created.");
			}
		} else {
			log.info("aws.dynamoDb.local needs to have a boolean value set in application.propeties");
		}
		return dynamoDbClient;
	}

	/**
	 * Creates the necessary tables.
	 */
	private void createTables(DynamoDbClient dynamoDbClient) {
	    
	    ListTablesResponse listTablesResponse = dynamoDbClient.listTables();

	    ClassPathScanningCandidateComponentProvider scanner =
	            new ClassPathScanningCandidateComponentProvider(false);

	    // Changed annotation to DynamoDbBean which is the v2 equivalent for model classes
	    scanner.addIncludeFilter(new AnnotationTypeFilter(DynamoDbBean.class));

	    for (BeanDefinition bd : scanner.findCandidateComponents(basePackage)) {
	        Class<?> clazz = null;
	        try {
	            clazz = Class.forName(bd.getBeanClassName());
	        } catch (ClassNotFoundException e) {
	            // Never will happen. Do nothing
	        }

	        // Get table name - in SDK v2 Enhanced, we need to extract it differently
	        // since the table name is usually derived from the class name or overridden in DynamoDbEnhancedClient configuration
	        String tableName = clazz.getSimpleName();
	        if(tableName.equalsIgnoreCase(analysisOutputModelName)) {
	        	tableName=analysisOutputTableName;
	        }
	        
	        if (!listTablesResponse.tableNames().contains(tableName)) {
	            String keyName = null;
	             keyName = findPartitionKeyName(clazz);
	            
	         /*   if (keyName == null) {
	            	throw new IllegalArgumentException(String.format("The class %s has a not valid Dynamo Hash Key",
                            bd.getBeanClassName()));
	            } 
	            */
                 if(keyName!=null) {
                	 List<AttributeDefinition> attributeDefinitions = new ArrayList<>();
     	            if (tableName.equalsIgnoreCase("ScienceMetrixDepartmentCategory") 
     	                    || 
     	                    tableName.equalsIgnoreCase("ScienceMetrix") 
     	                    || 
     	                    tableName.equalsIgnoreCase("PubMedArticle")) {
     	                attributeDefinitions.add(AttributeDefinition.builder()
     	                        .attributeName(keyName)
     	                        .attributeType(ScalarAttributeType.N)
     	                        .build());
     	            } else {
     	                attributeDefinitions.add(AttributeDefinition.builder()
     	                        .attributeName(keyName)
     	                        .attributeType(ScalarAttributeType.S)
     	                        .build());
     	            }
     	           
     	            List<KeySchemaElement> keySchemaElements = new ArrayList<>();
     	            keySchemaElements.add(KeySchemaElement.builder()
     	                    .attributeName(keyName)
     	                    .keyType(KeyType.HASH)
     	                    .build());

     	            CreateTableRequest.Builder requestBuilder = CreateTableRequest.builder()
     	                    .tableName(tableName)
     	                    .keySchema(keySchemaElements)
     	                    .attributeDefinitions(attributeDefinitions);
     	            
     	            if (billingMode != null && billingMode == BillingMode.PAY_PER_REQUEST) {
     	                requestBuilder.billingMode(BillingMode.PAY_PER_REQUEST);
     	            } else if (billingMode != null && billingMode == BillingMode.PROVISIONED) {
     	                requestBuilder.billingMode(BillingMode.PROVISIONED)
     	                    .provisionedThroughput(ProvisionedThroughput.builder()
     	                            .readCapacityUnits(READ_CAPACITY_UNITS)
     	                            .writeCapacityUnits(WRITE_CAPACITY_UNITS)
     	                            .build());
     	            }
     	            
     	            CreateTableRequest request = requestBuilder.build();
     	            dynamoDbClient.createTable(request);
     	            
     	            log.info("Waiting for DynamoDB table " + tableName + " to be created in AWS.");
     	            try {
     	                waitUntilTableActive(dynamoDbClient, tableName);
     	            } catch (Exception e) {
     	                log.error(e.getMessage());
     	            }
     	            log.info("DynamoDB table " + tableName + " has been created in AWS.");
                 }
	           
	        } else {
	            log.info("DynamoDB table " + tableName + " required for ReCiter is already created.");
	        }
	    }
	}

	private void waitUntilTableActive(DynamoDbClient dynamoDbClient, String tableName) throws InterruptedException {
	    boolean isTableActive = false;
	    int attempts = 0;
	    int maxAttempts = 60; // Set a maximum number of attempts (60 seconds timeout)
	    
	    while (!isTableActive && attempts < maxAttempts) {
	        try {
	            DescribeTableResponse response = dynamoDbClient.describeTable(DescribeTableRequest.builder()
	                    .tableName(tableName)
	                    .build());
	            isTableActive = response.table().tableStatus() == TableStatus.ACTIVE;
	            
	            if (!isTableActive) {
	                Thread.sleep(1000);
	                attempts++;
	            }
	        } catch (DynamoDbException e) {
	            log.warn("Error checking table status: {}", e.getMessage());
	            Thread.sleep(1000);
	            attempts++;
	        }
	    }
	    
	    if (!isTableActive) {
	        throw new RuntimeException("Table " + tableName + " never became active after " + maxAttempts + " seconds");
	    }
	}

	private String findPartitionKeyName(Class<?> clazz) {
	    // First check fields
	    for (Field field : clazz.getDeclaredFields()) {
	        if (field.isAnnotationPresent(DynamoDbPartitionKey.class)) {
	            return field.getName();
	        }
	    }
	    for (Method method : clazz.getDeclaredMethods()) {
	        if (method.isAnnotationPresent(DynamoDbPartitionKey.class)) {
	            // Check if it's a getter method (starts with "get" and has no parameters)
	            if (method.getName().startsWith("get") && method.getParameterCount() == 0) {
	                if (method.isAnnotationPresent(DynamoDbAttribute.class)) {
	                    DynamoDbAttribute annotation = method.getAnnotation(DynamoDbAttribute.class);
	                    return annotation.value();
	                }
	            }
	        }
	    }
	    return null;
	}
}